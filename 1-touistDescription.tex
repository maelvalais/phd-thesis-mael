% %----------------------------------------------------------------------
% \section{Historique}\label{sec:introduction}
% %----------------------------------------------------------------------

% O.\ Gasquet et F.\ Maris enseignent à l'Université Paul Sabatier à Toulouse la logique à différents niveaux, en démarrant des cours d'introduction à la logique propositionnelle, jusqu'à des sujets avancés pour les étudiants en Master, comme la logique modale ou la planification basée sur la logique. % S. Ben Slimane, A. Comte, A. Heba, O. Lezaud et 
% M.\ Valais était étudiant en Master de la même université. Il a participé à la mise en \oe uvre de \touist durant les trois mois de son projet de Master en tant que chef de projet (4 autres étudiants travaillait de concert avec lui).

% \subsubsection*{Motivation des étudiants}
% Au début des études de premier cycle, nous (enseignants) avons constaté que la motivation des étudiants peut être améliorée en leur montrant que la logique est très utile pour les informaticiens et que l'informatique ne consiste pas seulement à écrire du code C ou Java. Classiquement, la logique est motivée par des exemples abstraits ou, au mieux, par des exemples ludiques. A un moment, nous avons pensé qu'il serait préférable de leur montrer et pas seulement de leur dire qu'avec un peu de connaissance, la logique peut être utilisée pour résoudre des problèmes difficiles que la taille empêche de résoudre facilement à la main ou exigerait une programmation assez complexe en C ou tout autre langage de programmation. \\


Dès le départ, nos exigences étaient que l'outil devait :
%
être très facile à installer et à utiliser, sans syntaxe complexe ; 
%
pouvoir être utilisé comme une boîte noire sans connaître son fonctionnement interne  (éditeur intégré de formules traduites automatiquement et de manière transparente dans le langage d'entrée du solveur considéré) ;
%
ne requérir aucune mise en forme normale,  ordonnancement de clauses, \etc ;
%
ne nécessiter qu'un minimum de connaissances en logique.

%Comme nous ne pouvions pas trouver un outil existant satisfaisant ces exigences, en 2010, nous avons commencé à développer le nôtre, et nous sommes arrivés à l'idée de développer simplement une interface qui permet d'utiliser très confortablement un prouveur SAT (à savoir SAT4J \cite{DBLP:journals/jsat/BerreP10}) : cet outil avait été appelé \satoulouse et est décrit dans \cite{GaScSt2011}. 

Avec \touist, les étudiants peuvent expérimenter par eux-même qu'un langage logique n'est pas seulement descriptif mais peut aussi conduire à des calculs qui résolvent des problèmes concrets. En particulier, \touist leur permet de résoudre des Sudokus assez facilement, ainsi que beaucoup d'autres problèmes combinatoires (emplois du temps, coloration de carte, circuits électroniques, \etc).

Voici les principales facilités qu'offre \touist :
\begin{itemize}
\item les formules entrées n'ont pas besoin d'être sous forme clausale et des connecteurs arbitraires peuvent être utilisés, la mise sous forme normale est faite dynamiquement pendant la saisie au clavier de l'utilisateur ;

\item facilités d'utilisation de conjonctions ou disjonctions indicées comme :
\small $$\bigwedge_{i\in\{1..9\}}
  \bigvee_{j\in\{1..9\}}\bigwedge_{n\in\{1..9\}}\bigwedge_{m\in\{1..9\},m\neq
    n}(p_{i,j,n}\rightarrow \lnot p_{i,j,m})$$
\normalsize exprimant qu'une case de coordonnées $(i,j)$ contient au plus un nombre compris entre $1$ et $9$.

%\item modèles affichés dans la syntaxe de la formule entrée ;

\item plusieurs solveurs sont disponibles (SAT, QF\_LRA, QF\_LIA, QF\_RDL, QF\_IDL et QBF) et le langage admissible par \touist s'adapte facilement ;

\item définition d'ensembles de domaines : $\bigwedge_{i\in A}$ vs. $\bigwedge_{i\in\{Paris,London,Roma,Madrid\}}$

\item liaisons multiples sur les indices: $\bigwedge_{i\in A,j\in B}$ vs. $\bigwedge_{i\in \cdots} \bigwedge_{j\in \cdots}$

\item calculs riches sur les indices ainsi que sur les ensembles de domaines: $\bigwedge_{i\in (A\cup (B \cap C))}$

\item primitives de contraintes de cardinalité : \guill{au moins}, \guill{au plus}, \guill{exactement}, \guill{$n$ valeurs sont vraies parmi un ensemble de valeurs données}, \etc

\item prédicats pouvant être des variables définies sur des ensembles de domaines: $\bigwedge_{X\in \{A,B\},i\in \{1,2\}} X(i)$ \vs $\bigwedge_{i\in \{1,2\}} (A(i) \land B(i))$

\item littéraux spéciaux définissant des contraintes entre nombres entiers ou réels : ($x+y\leq z$)

\item parcours facile des modèles successivement calculés par les solveurs

\item expressions régulières permettant un filtrage des littéraux pertinents

\item possibilité d'utiliser le logiciel en ligne de commande et/ou batch

\item nombreuses fonctionnalités d'édition et améliorations
\end{itemize}
Ainsi, il est possible de montrer la puissance de la logique propositionnelle à des étudiants qui ont été formés quelques heures à la formalisation de phrases en logique et qui ont acquis les notions de bases de validité et satisfiabilité pour résoudre automatiquement des Sudokus par exemple. 

Une présentation plus complète de \touist peut être trouvée dans \cite{DBLP:journals/corr/SlimaneCGHLMV15}. \touist est téléchargeable à l'adresse \url{https://www.irit.fr/touist}. Cette page donne aussi accès au manuel complet du langage et de l'utilisation du logiciel.





% \subsubsection*{Travaux pratiques avec \satoulouse}
% Mais ce n'est pas toute l'histoire, puisque le même solveur SAT peut être utilisé pour résoudre de nombreux autres problèmes combinatoires aussi facilement que pour le Sudoku : ils suffit juste de formaliser les contraintes. Nos étudiants sont invités à le faire pour : des emplois du temps, des colorations de cartes... \satoulouse a été utilisé pendant trois ans par environ 400 étudiants avec une grande satisfaction. En particulier, les étudiants l'ont utilisé pour effectuer des devoirs à long terme dans l'esprit de la programmation de projets : nous leur donnons un problème logique à résoudre (trop gros pour être résolu à la main), ils doivent le formaliser et ensuite utiliser cette formalisation pour le résoudre. Par exemple, un problème de stockage de produits chimiques qui doivent être stockés dans des salles identiques/contigües/non-contigües en fonction de leur degré de compatibilité. Les étudiants doivent résoudre un cas impliquant beaucoup de produits chimiques.


% \subsubsection*{Limites de \satoulouse et genèse de \touist}
% Mais pendant ces années, nous avons remarqué quelques limitations dommageables de \satoulouse : de nombreux bugs, des défauts dans l'interface, le manque de modularité (si l'on souhaite changer le prouveur SAT utilisé), l'ambiguïté et les limites de son langage, etc.

% Par exemple, des problèmes impliquant des contraintes de cardinalité, comme les règles du jeu de Takuzu\footnote{Connu aussi sous le nom de Binero. Voir \url{http://fr.wikipedia.org/wiki/Takuzu}} qui nécessitent de compter des 0 et des 1, ne peuvent être facilement formalisés : il manque des fonctionnalités permettant d'exprimer des choses comme \guill{exactement 5 parmi 10 propositions sont vraies}. 

% De plus, \satoulouse n'offre pas la possibilité de parcourir l'ensemble des modèles fournis par le solveur, il en retourne seulement un.

% Les le\c cons tirées de trois années d'utilisation de \satoulouse sont que beaucoup de nos étudiants en informatique ont clairement pris conscience que la logique avait des applications réelles en ce qui concerne la résolution de problèmes, et beaucoup d'entre-eux ont acquis une capacité dans la formalisation de problèmes. Mais les défauts de \satoulouse rendent le débogage vraiment difficile, d'une part parce qu'un seul modèle est affiché et en raison de la fa\c con dont ce modèle est affiché, et d'autre part à cause des faibles capacités d'édition dont il dispose. En outre, seuls des problèmes combinatoires purs peuvent être traités, ce qui limite lourdement la prétention de résolution d'une large gamme de problèmes par \satoulouse concernant les problèmes du monde réel.

% Un autre inconvénient de \satoulouse , pas nécessairement lié \`{a} l'enseignement de la logique, est son incapacité \`{a} être utilisé \`{a} partir de la ligne de commande : des chercheurs ou des ingénieurs qui souhaiteraient l'utiliser intensivement trouveraient fastidieux de taper des problèmes en entrée.

% Enfin, l'extension \`{a} des théories plus riches est également quelque-chose qui peut intéresser les chercheurs, les ingénieurs ou les étudiants de cycles supérieurs. \satoulouse n'est certainement pas adapté pour la satisfiabilité modulo théories ou pour résoudre des problèmes de planification alors que la même architecture logicielle pourrait être utilisée en changeant juste le solveur.


% Il y a quelques mois, nous avons commencé \`{a} développer un nouveau logiciel qui comblerait ces lacunes et remplirait nos attentes. Nous l'avons appelé \touist qui signifie TOUlouse Integrated Satisfiability Tool et doit être prononcé \guill{twist}.
%  \touist est bien sûr à la disposition du public pour téléchargement à partir du site suivant :
% \begin{center}\url{ https://github.com/olzd/touist/releases }\end{center}


% Pour résumer, voici quelques fonctionnalités offertes par \touist et que \satoulouse ne propose pas :
% \begin{itemize}
% \item définition d'ensembles de domaines : $\bigwedge_{i\in A}$ vs. $\bigwedge_{i\in\{Paris,London,Roma,Madrid\}}$

% \item liaisons multiples sur les indices: $\bigwedge_{i\in A,j\in B}$ vs. $\bigwedge_{i\in \cdots} \bigwedge_{j\in \cdots}$

% \item calculs riches sur les indices ainsi que sur les ensembles de domaines: $\bigwedge_{i\in (A\cup (B \cap C))}$

% \item primitives de contraintes de cardinalité intégrées: \guill{auMoins} (resp.\ \guill{auPlus}, \guill{exactement}) \emph{tant} de valeurs sont vraies parmi \emph{ces valeurs}

% \item les prédicats peuvent également être des variables définies sur des ensembles de domaines: $\bigwedge_{X\in \{A,B\},i\in \{1,2\}} X(i)$ \vs $\bigwedge_{i\in \{1,2\}} (A(i)\AND B(i))$

% \item littéraux spéciaux définissant des contraintes entre nombres entiers ou réels : ($x+y\leq z$)

% \item parcours facile des modèles successivement calculés par les solveurs

% \item expressions régulières permettant un filtrage des littéraux pertinents

% \item possibilité d'utiliser le logiciel en ligne de commande et/ou batch

% \item nombreuses fonctionnalités d'édition et améliorations
% \end{itemize}



% %......................................................................
% \section{Vue d'ensemble de \touist}\label{sec:sat_interface}
% %......................................................................


% \touist est composé de trois modules, mais l'utilisateur standard ne verra que l'un d'entre eux : l'interface. Dans la suite nous insistons principalement sur cette dernière plut\^ot que sur le traducteur et le solveur. L'architecture globale est illustrée par la figure~\ref{fig:architectureTouisT}: 

% \begin{figure}[htbp]
% \centering
% \includegraphics[scale=0.37]{Images/DiagTouist.png}
%   \caption{Architecture de TouIST}
%   \label{fig:architectureTouisT}
% \end{figure}

% Avec \touist on accède à un éditeur puissant et convivial pour éditer des formules logiques complexes et des contraintes variées comme :

% $$\bigwedge_{i \in \{1..9\}} (P_i \IMPL Q_{i+1})$$

% qui abrège confortablement :\\ 

% $(P_1 \IMPL Q_2) \AND (P_2 \IMPL Q_3) \AND \ldots (P_9\IMPL Q_{10})$. 
% \\

% Une fois qu'un ensemble de formules a été donné à l'interface, sa satisfiabilité peut être vérifiée : l'interface peut l'envoyer au prouveur qui retourne un modèle, affiché comme le montre la figure \ref{fig:ExampleOfAModel} si un tel modèle existe. Ensuite par l'intermédiaire de l'interface, l'utilisateur peut par exemple demander d'autres modèles (bouton \guill{Next} de l'interface). Contrairement à \satoulouse qui aurait nécessité de modifier les formules pour interdire le modèle et de relancer le solveur, \touist conserve une instance du solveur en attente, ce qui permet d'obtenir les modèles suivants bien plus rapidement.

% \begin{figure}[htbp]
% \centering
% \includegraphics[scale=0.27]{Images/ExampleOfAModel.png}
%   \caption{Affichage de modèle}
%   \label{fig:ExampleOfAModel}
% \end{figure}

% Les modèles renvoyés par le solveur sont totaux : une valeur est affectée \`{a} chacune des variables apparaissant dans les formules envoyées au solveur. L'utilisateur peut sélectionner uniquement les propositions vraies ou les propositions fausses. Il peut également sélectionner des sous-ensembles de variables en tapant une expression régulière pour les filtrer.


% \section{Détail de ce qui peut être fait avec \touist\label{sec:sat_tobedone}}

% \subsection{Ensembles de domaines}
% Avec le temps, nous avons remarqué que nous avions souvent besoin d'écrire des choses comme :
% $$\begin{aligned}\bigwedge_{i \in \{1..9\}} \bigwedge_{j \in \{1..9\}}\bigwedge_{ m\in \{A,B,C,D,E,F,G,H,I\}} \hspace{2cm}\\ \left( P_{i,j,m}\IMPL \bigwedge_{n \in \{A,B,C,D,E,F,G,H,I\}|m\neq n}\NOT P_{i,j,n}\right)\end{aligned}$$
% Si on lit $P_{i,j,m}$ comme  \guill{il y a la lettre $m$ dans la case $(i,j)$} d'une grille $9\times 9$, la formule ci-dessus exprime qu'il y a \emph{au plus} une lettre parmi `A' ... `I' dans chaque case. 

% Ces ensembles $\{1..9\}$ et $\{A,B,C,D,E,F,G,H,I\}$ sont des \emph{ensembles de domaines}, et avec \touist l'utilisateur peut définir autant d'ensembles de domaines qu'il le souhaite, par exemple :

% \begin{verbatim}
%   $N=[1..9]
%   $L=[A,B,C,D,E,F,G,H,I]
% \end{verbatim}

% et ainsi écrire la formule précédente comme :
% $$\bigwedge_{i \in N} \bigwedge_{j \in N}\bigwedge_{ m\in L}P_{i,j,m}\IMPL \bigwedge_{n \in L|m\neq n}\NOT P_{i,j,n}$$
% De plus, les opérations usuelles sur les ensembles ($\cup$, $\cap$, $\setminus$, ...) peuvent être utilisées pour définir d'autres ensembles.


% \subsection{Formules propositionelles}

% Les formules de \touist sont basées sur des variables propositionnelles (qui peuvent être indicées) et les opérateurs logiques usuels ($\AND$, $\OR$, $\IMPL$, $\NOT$, $\IFF$). Ainsi on peut taper des formules usuelles simples comme $Pluie \IMPL Nuages$. Mais en plus, nous fournissons des opérateurs logiques de haut niveau qui permettent d'exprimer des assertions complexes dans une forme très compacte.

% \subsubsection*{Conjonctions et disjonctions généralisées}
% Elles permettent d'exprimer des conjonctions et des disjonctions sur des formules contenant des paramètres qui varient, par exemple :
% \begin{itemize}
% \item $ \bigwedge_{i \in N} P_i$, o\`u $N$ est l'ensemble de domaine défini précédemment.\\
%   Elle représente la conjonction
%   $P_1 \AND P_2 \AND \ldots \AND P_9$. 
% \item $\bigvee_{i \in E} P_i$.
% \end{itemize}

% Bien sûr, ces opérateurs peuvent être imbriqués comme dans :
% $$\bigwedge_{i \in N} \bigwedge_{j \in N}\bigvee_{ m\in L}P_{i,j,m}$$

% qui indique que dans chaque cellule se trouve au moins une lettre.


% \subsubsection*{Contraintes de cardinalité}
% C'était l'un des sujets \guill{laissé pour le futur} de \cite{GaScSt2011}.
% Ces opérateurs logiques moins classiques sont disponibles dans \touist : il permettent de réduire drastiquement la taille de certaines formules, ce sont : $\atM{}{}$, $\atL{}{}$ et $\exact{}{}$.\\ L'exemple suivant décrit leur signification :
% \begin{itemize}
% \item $\atM{i \in N}{2} P_i$ représente \guill{pour au plus deux valeurs de $i \in N$ $P(i)$ est vraie};
% \item $\atL{i \in N}{2} P_i$ représente \guill{pour au moins deux valeurs de $i \in N$ $P(i)$ est vraie};
% \item $\exact{i \in N}{2} P_i$ représente \guill{pour exactement deux valeurs de $i \in N$ $P(i)$ est vraie}.
% \end{itemize}
% La disjonction généralisée est en fait un cas particulier de ceci (au moins une est vraie), la conjonction aussi (au plus 0 est fausse), et le ou exclusif peut être vu comme exactement une parmi deux est vraie. \\
% Rappelons qu'avec des opérateurs logiques classiques et avec $N$ contenant 9 éléments, $\atM{i \in N}{3} P_i$ devrait nécessiter une formule contenant 84 propositions $P_i$ puisque cela revient à choisir 3 parmi 9 ce qui donne $\binom{9}{3}$ possibilités, et ni $\bigwedge$ ni $\bigvee$ n'aideraient beaucoup. 

% \subsubsection*{Contraintes et calculs sur des indices}

% Souvent nous avons besoin d'ajouter des contraintes sur les indices, par exemple :
% $$\bigwedge_{i \in E } \bigwedge_{j \in E  | i \neq j}P_{i,j}$$
% qui signifie que $P_{i,j}$ est vraie lorsque $i\neq j$. 

% C'était la seule contrainte disponible dans \satoulouse, maintenant dans \touist la gamme de possibilités à été largement enrichie. Les contraintes peuvent inclure des opérateurs usuels de comparaison comme $<$, $>$, $\leq$, $\geq$, $\neq$, $=$ et ces comparaisons peuvent s'appliquer non seulement aux indices, mais aussi à toute expression arithmétique impliquant des indices et $+$, $-$, $*$, $/$, $\mod$, $\sqrt{\phantom{x}}$. 

% Exprimer une phrase comme \guill{chaque case $(i,j)$ contient un nombre qui n'est pas égal à $i+j$} donnera :
% $$\bigwedge_{i \in N } \bigwedge_{j \in N} \bigvee_{k \in N|k\neq i+j} P_{i,j,k}$$
% Bien sûr, \emph{toutes ces phrases} pourraient être exprimées avec les opérateurs logiques usuels bruts, mais ceci serait un travail fastidieux. Néanmoins, les étudiants doivent savoir ce qui est derrière la scène, et qu'une telle formule est l'abréviation de quelque chose comme :
% $$P_{1,1,1}\vee P_{1,1,3}\vee P_{1,1,4}\ldots P_{1,2,1}\vee P_{1,2,2}\vee P_{1,2,4}\vee \ldots $$
% qui est très long et terne.



% \subsection{Aspects techniques}

% \subsubsection*{Langage d'entrée vs Langage d'affichage}

% Les formules que nous avons vues précédemment sont écrites dans le \emph{langage d'affichage} (style \LaTeX), mais tous ces symboles ne sont pas disponibles sur les claviers, ainsi pour écrire les formules et ensembles de domaines, l'utilisateur utilisera le \emph{langage d'entrée}.
% Par exemple, la formule précédente avec l'ensemble associé $N$ sera tapée (les variables sont préfixées par \$) :
% \begin{verbatim}
% bigand $i,$j in $N,$N:
%   bigor $k in $N when $k != $i+$j:
%     P($i,$j,$k)
%   end
% end
% \end{verbatim}
% Mais \touist les affiche immédiatement en style \LaTeX\ comme on peut le voir dans le panneau droit montré sur la figure \ref{fig:LatexDisplay}.
% La définition de l'ensemble $N$ est faite dans l'onglet \guill{Ensembles}.

% \begin{figure*}[htbp]
% \centering
% \includegraphics[scale=0.45]{Images/LatexDisplay.png}
%   \caption{Affichage en style \LaTeX}
%   \label{fig:LatexDisplay}
% \end{figure*}


% En outre, les formules peuvent être tapées à la main dans la fenêtre d'édition, ou introduites dans une sorte d'éditeur dirigé par la syntaxe, en raffinant progressivement l'arbre syntaxique, ou encore elles peuvent être importées à partir d'un fichier externe.





%\begin{figure*}[ht]
%  \centering
%  \includegraphics[scale=.4]{touist1.png}
%  \caption{Interface de TouIST}
%  \label{fig:touist}
%\end{figure*}


%%......................................................................
%\section{Behind the scenes}\label{sec:sat_behind}
%
%\input{sat_scenes}
%

% %......................................................................
% \section{Sujets avancés pour les étudiants de cycles supérieurs}\label{sec:advanced_topics}
% %......................................................................


% Dans ce qui suit, nous présentons très succictement quelques fonctionnalités avancées de \touist. Elles devraient intéresser les étudiants de cycles supérieurs et leurs enseignants bien sûr. Elles concernent SMT (SAT Modulo Theories), la planification par satisfaction de base de clauses (planification SAT) et leur combinaison la planification SMT.


% \subsection{SMT: SAT Modulo Theories}

% Certains problèmes combinatoires nécessitent néanmoins de traiter des calculs sur les nombre naturels ou réels. Ceci peut être fait en utilisant seulement la logique propositionnelle (par exemple, $2+3=5$ pourrait être codé par $add_{2,3,5}$), mais c'est très inconfortable à moins qu'il n'y ait que quelques additions à faire. Ne parlons même pas des opérations de multiplication ou plus complexes. L'idée derrière la genèse de SMT a été de combiner des solveurs SAT avec un solveur arithmétique dans le but d'améliorer le traitement de la partie arithmétique du raisonnement. Dans de nombreux cas, ceci n'améliorera pas seulement l'efficacité du solveur, mais permettra aussi d'exprimer les contraintes arithmétiques des problèmes d'une manière radicalement plus compacte.

% Pensez au jeu de Kamaji\footnote{\url{http://fr.wikipedia.org/wiki/Kamaji}}  o\`u le joueur doit grouper des nombres adjacents dans une grille de sorte que leur somme soit égale à un nombre fixe. Résoudre le jeu nécessite essentiellement un raisonnement logique mais a aussi besoin d'un peu d'arithmétique (addition).


% Si $x_{i,j}$ pour chaque case $(i,j)$ est un entier et $G(i,j,i,k)$ représente le fait que les cases $(i,j)$ à $(i,k)$ de la ligne $i$ forment un groupe, la contrainte de somme pourrait être exprimée par :
% $$\sum_{m\in E}x_{i,m}=N$$
% o\`u $N$ est le nombre fixe et $E$ est $\{j,j+1,\ldots,k\}$. La logique propositionnelle pure n'est certainement pas adaptée pour de telles phrases !




% \subsection{\touist pour la planification classique SAT}

% En Intelligence Artificielle, la \emph{planification} est un processus cognitif qui consiste à générer automatiquement, au travers d'une procédure formelle, un résultat articulé sous la forme d'un système de décision intégré appelé \emph{plan}. Le plan est généralement sous la forme d'une collection organisée d'\emph{actions} et il doit permettre à l'univers d'évoluer de l'\emph{état initial} à un état qui satisfait le \emph{but}. Dans le cadre classique, le plus restrictif, on considère les actions comme des transitions instantanées sans prendre en compte le temps.

% La planification par satisfaction de base de clauses (planification SAT) a été introduite avec le planificateur SATPLAN \cite{kautzS92_planning_sat}. Dans cette approche, on travaille directement sur un ensemble fini de variables propositionnelles. Deux actions identiques pouvant apparaître à des endroits différents d'un même plan doivent pouvoir être différenciées et on leur associe donc des propositions différentes. Comme on ne connaît pas à l'avance la longueur d'un plan solution d'un problème, on ne peut pas créer un codage unique permettant de le résoudre puisqu'il faudrait créer une infinité de variables propositionnelles pour représenter toutes les actions de tous les plans possibles. La solution la plus commune consiste alors à créer un codage représentant tous les plans d'une longueur $k$ fixée. La base de clause ainsi obtenue est donnée en entrée à un solveur SAT qui retourne, lorsqu'il existe, un modèle de cette base. Le décodage de ce modèle permet alors d'obtenir un plan-solution. Si la résolution du codage ne donne pas de modèle, la valeur de $k$ est augmentée et le processus réitéré. Pour la complétude du procédé, tous ces modèles doivent correspondre exactement à tous les plans solutions d'une longueur fixée du problème.


% Une différence importante de \touist, en comparaison avec \satoulouse, est sa capacité à prendre en compte à la fois des formules logiques et ensembles de domaines. Par exemple, si l'on veut résoudre un problème de planification particulier, \satoulouse est facile à utiliser pour décrire le problème et le résoudre via un solveur SAT. Mais si notre objectif est de résoudre plusieurs problèmes de planification génériques, nous pouvons profiter de la flexibilité de \touist qui permet à l'utilisateur de décrire une méthode générique de résolution avec des règles encodées comme formules et d'utiliser des ensembles de domaines pour décrire chaque problème de planification particulier. De nombreuses règles de codage pour la résolution de problèmes de planification ont déjà été proposées \cite{kautzS92_planning_sat,MaliK99_plan_space_encodings,Rintanen:2006}. Comme exemple d'une telle règle nous donnons ci-après un codage des \emph{frame-axioms}. Si un fait est faux à une étape $i-1$ d'un plan solution et devient vrai à l'étape $i$, alors la disjonction des actions qui peuvent établir le fait à l'étape $i$ du plan est vraie. C'est à dire, au moins une action qui établit le fait doit avoir été appliquée.


%   \[\begin{aligned}\bigwedge_{i\in\{1..longueur\_plan\}}
%   \bigwedge_{f\in Faits} \hspace{4cm}\\
%   \left((\lnot f(i-1) \wedge f(i)) \Rightarrow 
%   \bigvee_{a\in Actions / f\in Effets(a)} a(i)\right)\end{aligned}\]
% \\


% \subsection{\touist pour la planification temporelle SMT}

% Pour résoudre des problèmes de planification réels, l'une des principales difficultés à surmonter consiste à prendre en compte la dimension temporelle. En effet, de nombreux problèmes du monde réel nécessitent, pour être résolus ou exécutés plus efficacement, la prise en compte de la durée des actions, des instants auxquels des évènements se produisent, ou encore la concurrence d'actions.

% En complément de SAT, notre nouvelle plateforme \touist est capable de gérer des théories comme la différence logique ou l'arithmétique linéaire sur les nombres entiers (QF\_IDL, QF\_LIA) ou les nombres réels (QF\_RDL, QF\_LRA), et d'appeler un solveur SMT pour trouver une solution. Pour être résolus, les problèmes de planification temporelle issus du monde réel nécessitent une représentation continue du temps, et donc, l'utilisation de nombres réels dans les codages logiques. \touist peut être utilisé pour résoudre de tels problèmes impliquant des actions avec durée, des évènements exogènes et des buts temporellement étendus, par exemple avec les règles de codage proposées dans \cite{MarisRegnier08}. Nous donnons ci-après un codage des exclusions mutuelles temporelles d'actions. Si deux actions $a$ et $b$ produisant respectivement une proposition $p$ et sa négation sont actives dans le plan ($a \wedge b$ est vrai), alors l'intervalle de temps $[\tau(a \mid\rightarrow p), \tau(a \rightarrow\mid p)]$ correspondant à l'activation de $p$, et l'intervalle de temps $[\tau(b \mid\rightarrow \lnot p), \tau(b \rightarrow\mid \lnot p)]$ correspondant à l'activation de $\NOT p$ sont disjoints. Dans ce cas, il faut ajouter une disjonction pour imposer que la fin de l'un de ces intervalles soit strictement avant le début de l'autre.

%   \[\bigwedge_{a\in Actions}
%   \bigwedge_{b\in Actions}
%   \bigwedge_{f\in Faits | f\in Effets(a) \wedge \lnot f\in Effets(b)}\]
%   \[\left(\left(a \wedge b\right) \Rightarrow 
%   \left( \begin{aligned} \left(\tau(b \rightarrow\mid \lnot f) < \tau(a \mid\rightarrow f)\right)
%     \\ \vee
%     \left(\tau(a \rightarrow\mid f) < \tau(b \mid\rightarrow \lnot f)\right)
%  \end{aligned} \right)\right) \]


%----------------------------------------------------------------------

%\vspace{-1cm}