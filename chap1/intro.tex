\fred{Intro à faire}

\section{Introduction générale au domaine}

\fred{La compilation de problèmes en logique bla bla résolution avec des solveurs bla bla}

\section{Le cadre de travail}

\subsection{Les solveurs pour les logiques classiques}

\subsubsection{SAT : satisfaction de formules booléennes}

\subsubsection{SMT : SAT Modulo Theories}
\input{intro-sat-smt-qbf.tex}

\subsubsection{QBF : formules booléennes quantifiées}
Quantified Boolean Formula (QBF) est connu comme étant le problème de référence pour la classe de complexité PSPACE (\cite{Stockmeyer:1973:WPR:800125.804029}). C'est une extension de la logique propositionnelle permettant de quantifier sur les variables propositionnelles. 

Par exemple, $\forall p \exists q.p \leftrightarrow q$ se lit : pour toute valeur de vérité de $p$, il existe une valeur de vérité de $q$ tel que $p \leftrightarrow q$ est vrai. Cette formule est vraie (il suffit de choisir la même valeur pour $q$ que pour $p$). Alors que  $\exists p \forall q.p \lor q$ ne l'est pas. Ainsi, une formule booléenne quantifiée est toujours SOIT vraie SOIT fausse. 

De fait, à toute formule QBF peut être associée une formule propositionnelle sans variables car par définition : 
$\forall p.\Phi$ est vraie ssi $\Phi_{[p:=\top]} \wedge \Phi_{[p:=\bot]}$ l'est, et $\exists p.\Phi$ est vraie ssi $\Phi_{[p:=\top]} \vee \Phi_{[p:=\bot]}$. 

La formule QBF peut être exponentiellement plus compacte que la formule propositionnelle correspondante. 

Par exemple à la formule $\forall p \exists q.p \leftrightarrow q$ correspond la formule propositionnelle \\
$\Big ( (\top \leftrightarrow \top)\vee (\top \leftrightarrow \bot) \Big ) \wedge \Big ( (\bot \leftrightarrow \top)\vee (\bot \leftrightarrow \bot) \Big )$

\subsection{La planification par compilation automatique}
\input{intro-planif.tex}

\section{Présentation de la thèse}

Dans cette thèse, nous nous sommes intéressés aux codages de problèmes en logique et tout particulièrement aux codages et à la résolution automatique de problèmes de planification en utilisant des solveurs.

Dans le chapitre~\ref{chap:codages}, nous présentons tout d'abord les langages logiques que nous allons utiliser avant d'illustrer leur utilisation au travers d'un exemple de codage du jeu de Nim. Nous présentons ensuite différents codages de problèmes de planification en logique. Nous nous plaçons dans un premier temps dans le cadre classique de la planification. Nous présentons des codages SAT de référence dans les espaces d'états \cite{KS92,KS95} et dans les espaces de plans \cite{MK99} avant d'introduire un nouveau codage dans les espaces de plans basé sur le découpage des liens causaux en modélisant la notion de condition ouverte. Nous présentons ensuite un codage QBF de référence basé sur l'utilisation d'une représentation d'arbre compact et des actions No-ops comme frame-axiomes \cite{DBLP:conf/ecai/CashmoreFG12,DBLP:phd/ethos/Cashmore13}. Nous introduisons alors deux nouveaux codages QBF compacts inspirés par les codages SAT précédemment introduits. Enfin, nous nous plaçons dans le cadre étendu de la planification temporelle et détaillons un codage SMT de référence \cite{MarisRegnier08} avant d'en présenter une adaptation plus compacte basée sur le découpage des liens causaux que nous avons proposé pour la planification classique.

Dans le chapitre~\ref{chap:touist} \fred{$\rightarrow$ Maël}
Nous comparons ensuite les performances des codages QBF de référence de problèmes de planification présentés dans la section~\ref{chap:codages:qbf:reference} et de nos nouveaux codages introduits dans la section~\ref{chap:codages:qbf:nouveaux}. Après avoir présenté le module \touistplan et les problèmes de planification de référence issus de différentes compétitions internationales de planification (IPC), nous montrons que nos codages sont plus efficace en terme de temps de résolution.